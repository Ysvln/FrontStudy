# 리액트 구동 원리 및 핵심 컨셉

## CSR (Client Side Rendering) & SSR (Server Side Rendering)

  <br/>
  
### 1. CSR 
- 렌더링이 클라이언트 쪽에서 일어난다.
- 서버는 요청을 받으면 클라이언트에 HTML과 JS를 보내준다.
- 클라이언트는 그것을 받아 렌더링 시작.
  <br/>
  <br/>

<img src="csr.png"/>
<br/>
<br/>

1. User가 Website 요청을 보낸다.
2. CDN이 HTML 파일과 JS로 접근할 수 있는 링크를 클라이언트로 보낸다.<br/>
   +) CDN : 엔드 유저의 요청에 '물리적'으로 가까운 서버에서 요청에 응답하는 방식 (aws의 cloudflare를 생각하면 된다고 함)
3. 클라이언트는 HTML과 JS를 다운로드 받는다.<br/>
   (이때 유저는 아무것도 볼 수 없다. -> 서버에서 처리 없이 클라이언트로 보내주기 때문에 자바스립트가 모두 다운로드 되고 실행이 끝나기 전까지 사용자는 볼 수 있는게 없다.)
4. 클라이언트는 JS를 다운로드 받는다.
5. 다운이 완료된 JS가 실행된다. 데이터를 위한 API가 호출된다.
   (이때 유저들은 placeholder를 보게 된다.)
6. 서버가 API로부터의 요청에 응답한다.
7. API로부터 받아온 data를 placeholder 자리에 넣어준다. 이제 페이지는 상호작용이 가능해진다.

### 2. SSR (Server Side Rendering)

- 서버쪽에서 렌더링 준비를 끝마친 상태로 클라이언트에 전달하는 방식.
  <br/>
  <br/>
  <img src="ssr.png"/>
  <br/>
  <br/>

1. User가 Website 요청을 보낸다.
2. Server는 'Ready to Render'. 즉, 즉시 렌더링 가능한 html파일을 만든다.
   (리소스 체크, 컴파일 후 완성된 HTML 컨텐츠로 만든다.)
3. 클라이언트에 전달되는 순간, 이미 렌더링 준비가 되어있기 때문에 HTML은 즉시 렌더링 된다. 그러나 사이트 자체는 조작 불가능하다. <br/>
   (Javascript가 읽히기 전이다. 서버에서 이미 '렌더 가능한' 상태로 클라이언트에 전달되기 때문에, JS가 다운로드 되는 동안 사용자는 무언가를 보고 있을 수 있다.)
4. 클라이언트가 자바스크립트를 다운받는다.
5. 다운 받아지고 있는 사이에 유저는 컨텐츠는 볼 수 있지만 사이트를 조작 할 수는 없다. 이때의 사용자 조작을 기억하고 있는다.
6. 브라우저가 Javascript 프레임워크를 실행한다.
7. JS까지 성공적으로 컴파일 되었기 때문에 기억하고 있던 사용자 조작이 실행되고 이제 웹 페이지는 상호작용 가능해진다.
   <br/>
   <br/>

### CSR & SSR 차이

1. 웹페이지를 로딩하는 시간

- 첫 페이지 로딩 시간 - CSR의 경우 HTML, CSS와 모든 스크립트들을 한 번에 불러온다. 반면 SSR은 필요한 부분의 HTML과 스크립트만 불러오게 된다. - 따라서 평균적으로 SSR이 더 빠르다.
  <br/>
- 나머지 로딩 시간 - 첫 페이지를 로딩한 후, 사이트의 다른 곳으로 이동하는 식의 동작을 가정하자. CSR은 이미 첫 페이지 로딩할 때 나머지 부분을 구성하는 코드를 받아왔기 때문에 빠르다. - 반면, SSR은 첫 페이지를 로딩한 과정을 정확하게 다시 실행한다. 그래서 더 느리다.
  <br/>
  <br/>

2. SEO 대응

- 검색 엔진은 자동화된 로봇인 '크롤러'로 웹 사이트들을 읽는다.
- CSR은 자바스크립트를 실행시켜 동적으로 컨텐츠가 생성되기 때문에 자바스크립트가 실행 되어야 metadata가 바뀌었다.
- (이전 크롤러들은 자바스크립트를 실행시키지 않았었기에 SEO 최적화가 필수적이었다.)
- SSR은 애초에 서버 사이드에서 컴파일되어 클라이언트로 넘어오기 때문에 크롤러에 대응하기 용이하다.
  <br/>
  <br/>

3. 서버 자원 사용
   SSR이 서버 자원을 더 많이 사용한다. 매번 서버에 요청을 하기 때문이다.

<br/>
<br/>
<br/>

---

<br/>
<br/>
<br/>

## Render

1.  렌더링?

- 화면에 표시할 웹 페이지를 만드는 과정
- 서버로부터 HTML 파일을 받아 브라우저에 보여주는 과정
  <br/>
  <br/>

2.  렌더링 순서

    1. HTML을 파싱하여 DOM 트리를 만든다.
       - 브라우저는 서버로부터 HTML 문서를 받고 브라우저의 렌더링 엔진은 HTML문서를 파싱 해서 DOM트리를 만든다.
    2. CSS를 파싱하여 CSSOM 트리를 만든다.

       - 외부 CSS 파일과 함께 포함된 스타일 요소를 파싱 하여 CSSOM(CSS Object Model) 트리를 만든다. (인라인으로 들어간 스타일 속성이 우선 순위)

    3. DOM과 CSSOM을 결합하여 렌더링 트리를 만든다.

    4. 렌더링 트리에서 각 노드의 크기와 위치를 계산한다.

       - 기기의 뷰포트 내에서 노드들의 정확한 위치와 크기를 계산하는 과정이 진행. 이 단계가 레이아웃 단계.

    5. 개별 노드를 화면에 그린다.
       - 렌더링 엔진은 페인트 이벤트를 발생시켜 렌더링 트리를 화면에 그리고, 이 과정을 페인팅 또는 래스터화라고 한다.
         <br/>
         <br/>

3.  레이아웃 변경

    1. DOM 엘리먼트 추가, 제거 또는 변경될 때

    2. CSS 스타일 추가, 제거 또는 변경될 때

    3. CSS 스타일을 직접 변경하거나, 클래스를 추가함으로써 레이아웃이 변경될 수 있다.

       - 엘리먼트의 길이를 변경하면, DOM 트리에 있는 다른 노드에 영향을 줄 수 있다.

    4. CSS3 애니메이션과 트랜지션. 애니메이션의 모든 프레임에서 리플로우가 발생.

    5. offsetWidth와 offsetHeight 의 사용할 때 offsetWidth 와 offsetHeight 속성을 읽으면, 초기 리플로우가 트리거되어 수치가 계산.

    6. 유저 행동. 유저 인터랙션으로 발생하는 hover 효과, 필트에 텍스트 입력, 창 크기 조정, 글꼴 크기 변경, 스타일시트 또는 글꼴 전환 등을 활성화하여 리플로우를 트리거할 수 있다.
       <br/>
       <br/>

4.  리액트에서의 렌더링

    1. 렌더링?

       - 리액트에서 렌더링이란 컴포넌트가 현재 props와 state의 상태에 기초해 UI를 어떻게 구성할지, 컴포넌트에게 작업을 요청하는 것을 의미

    2. 렌더링 과정

    - 2-1. React의 렌더링

      - 루트`(<div id="root"></div>)` DOM부터 시작해 플래그가 지정되어 있는 모든 컴포넌트를 찾아서 렌더링을 진행하는 것
      - root id는 public/index.html에 기본적으로 설정이 되어있다.

        ```jsx
        const root = ReactDOM.createRoot(document.getElementById("root"));
        const element = <h1>Hello, world</h1>;
        root.render(element);
        ```

      - DOM 엘리먼트를 ReactDOM.createRoot()에 전달한 다음, 그 React Element를 root.render()에 전달하는 과정을 거침
        <br/>
        <br/>

    - 2-2. React Element

      - type과 props를 가지는 React만의 객체
      - React.createElement()를 이용해 만들 수 있으며, type으로 HTML 태그 이름을 가지고, 그 이외의 특징을 props로 관리하는 객체 형태로 정의

      ```jsx
                  // createElement를 이용해서 React Element 만들기
                  React.createElement(
                    'div',
                    { className: 'name' },
                    'React'
                  )
                  // 위와 같은 의미로, JSX 문법
                  <div className='name'>React</div>


                  // createElement를 이용해서 만들어진 React Element 객체
                  {
                    type: 'div',
                    props: {
                      className: 'name',
                      children: 'React'
                    }
                  }

                  //
      ```

      - JSX 문법을 사용해 보통 위의 객체를 DOM 형태`(<div className='name'>React</div>)`로 정의하여 사용

    <br/>
    <br/>

    - 2-3. Virtual DOM <br/>

      - 가상 돔(Virtual DOM)은 실제 DOM의 구조와 비슷한 React 객체의 트리를 말함
      - Virtual DOM을 실제 DOM에 필요한 부분만 적절하게 반영해서 불필요한 수정이 일어나지 않도록 해준다.
      - 이 Virtual DOM의 가장 큰 장점은 개발자가 직접 DOM을 조작하지 않아도 된다는 점이고, 이러한 과정을 모두 자동화해준다는 장점을 갖고 있다.
      - DOM의 수정을 batch로 한 번에 처리하기 때문에 리렌더링 연산을 최소화 할 수 있다.

    <br/>
    <br/>

    3. 리렌더링 <br/>

       - 리액트에선 초기에 한번 렌더링을 진행하고, 그 이후에 특정 조건이 발생하면 다시 렌더링을 진행

       - 리렌더링 되는 조건
         - 내부 상태(state) 변경시
         - 부모에게 전달받은 값(props) 변경시
         - 중앙 상태값(Context value 혹은 redux store) 변경시
         - 부모 컴포넌트가 리렌더링 되는 경우

---

## SPA & MPA
